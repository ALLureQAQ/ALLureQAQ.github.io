{"pages":[],"posts":[{"title":"第一次周报","text":"1.本周学习方向：了解前端开发、算法2.学习参考： https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/10009024?fr=aladdinhttps://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025?fr=aladdin 3.总结： 前端开发基础为网页制作，然后运用HTML，CSS及JavaScrip使网页更加美观，交互效果显著，功能更加强大。前端开发师主要将公司的要求与技术结合，做出能够吸引顾客，符合公司要求的成品，前端开发为顾客和公司之间搭建桥梁，不仅为顾客带来服务，也可以将顾客的反馈给予公司。 而算法就是在编写程序的一种思路，要考虑到算法能否实现还要考虑时间和空间复杂性，算法要有很多的数学思维，因为要运用有些数学方法来为程序构思。 4.LeetCode 题目1代码：网上的（emmm）https://paste.ubuntu.com/p/xWDHXnyfVj/ 我的：https://paste.ubuntu.com/p/C26wjdzfgZ/（还有一点问题） 思考：对于这次作业没有get到那个点，他提示原地算法，然后我就用条件控制，然后思路有问题无法实现开头数字重复删除的效果，也没有考虑到数组大小为0的情况。需要提高自己的编程思维。 5.下周进度 明确实验室的研发方向。我还是比较喜欢算法。。。。","link":"/2018/11/30/1111/"},{"title":"第三次周报","text":"1.本周学习方向： Java的工程、类、包 malloc函数 2.学习参考： https://blog.csdn.net/FX677588/article/details/52689565 https://baike.baidu.com/item/malloc%E5%87%BD%E6%95%B0/8582146?fr=aladdin 3.总结：java中的工程是最大的概念，就差不多是软件的概念版，而包与类，在我简单的了解面向对象后，感觉类就是一条规则，而包就是规则的集合，面向对象对我来说，就是根据对象制定好方法，规则，动作这一些可以直接使用。 4.LeetCode 题目1代码：https://paste.ubuntu.com/p/xGgVpqrb7Z/ 题目2代码：https://paste.ubuntu.com/p/nypvBh9Gfh/ 题目3代码：https://paste.ubuntu.com/p/PRbcmvpqxC/ 思考：后两道题都需要malloc函数(用于申请内存) 5.下周进度 指针、地址 初步学习Java","link":"/2018/12/25/33333/"},{"title":"第二次周报","text":"1.本周学习方向： java(只把环境装了一下。。。) 初识结构体 2.学习参考：https://blog.csdn.net/PioneerFan/article/details/83044993 https://blog.csdn.net/weixin_40709185/article/details/79841687 3.总结：Java面向对象的编程语言，Java有两个优点,一是Java稳定，应用广泛，一定时期内很难被其他编程语言取代;二是许多大型系统都是用java开发，也不可能轻易使用其他语言待遇。 而结构体我个人觉得是数据库+数组的样子。储存数据也能调用数据。并且结构体与指针结合，是个难点。 4.LeetCode 题目1代码：https://paste.ubuntu.com/p/VGHbTDm686/ 题目2代码：https://paste.ubuntu.com/p/qJysqwZPwM/ 题目3代码：https://paste.ubuntu.com/p/qJysqwZPwM/ 思考：第一题股票，只需将正盈利的和计算，运用循环+if即可第二题旋转字符运用前面的原地算法。第三题直接进行比较，比出相同跳出循环即可。（详情看解题思路） 5.下周进度1.java熟悉操作，争取打出hello，world（滑稽）。 2.复习准备c语言考试 3.深入结构体。","link":"/2018/12/12/222/"},{"title":"第六次周报","text":"1.本周学习方向：Java2.学习参考：https://www.bilibili.com/video/av29306544/?p=107 3.总结： 数组 与c语言差不多。。 异常机制 在设计时，需要输入输出，会有问题出现，就是异常，需要对不同的异常，做出不同的反馈。 4.LeetCode 爬楼梯与最大子序和 https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/23/dynamic-programming/54/ 5.下周进度 继续学习","link":"/2019/05/03/5555/"},{"title":"第5次周报","text":"1.本周学习方向： java 2.学习参考： https://www.bilibili.com/video/av29306544/ 百度搜索 3.总结： import(静态引入) 类似c的头文件 引入其他包的方法 备注：调用不同包中重名的方法，使用调用更明确的（想使用其他包，可明确包的名字） 继承 （子类 extends 父类）—-即子类可以使用父类中的属性和方法 注：不可使用private修饰的属性和方法 —java单继承 没有使用extends的类默认继承java.lang.object instance()判断是否为所创建的对象 左边为对象 右边为类 而继承父类的子类与父类的类为true 重写 在子类调用父类的方法时，如果子类中的方法名与父类中的重名，出现重写 效果为先执行父类的方法后再执行子类的方法 与多态有联系。 抽象类 抽象的方法必须再抽象的类（抽象类不能实例化，可以包含属性、方法、构造方法。只能用来被继承）中——抽象的方法必须在子类中实现 限制子类的设计！ 封装 封装指的就是将一些方法 属性用访问控制符（private、default、protected、public）来控制访问的权限，达到一个密闭的效果。 1. private 表示私有，只有自己类能访问 2. default表示没有修饰符修饰，只有同一个包的类能访问 3. protected表示可以被同一个包的类以及其他包中的子类访问 4. public表示可以被该项目的所有包中的所有类访问 4.下周进度 继续学习Java","link":"/2019/04/01/4444/"},{"title":"DaY1","text":"1.100天Python DaY1 2.总结：","link":"/2019/05/14/DAY1/"},{"title":"leetcode3","text":"第一题代码：https://paste.ubuntu.com/p/xGgVpqrb7Z/ int singleNumber(int* nums, int numsSize) { int m,n,x; for(m=0;m&lt;numsSize;m++) { x=0; for(n=0;n&lt;numsSize;n++) { if(nums[m]==nums[n]) { x++; } } if(x&lt;2) { break; } } return nums[m]; } 主要思路就是 不重复的的数重复次数小于2，因此以此为判断标准就可以 第二题代码:https://paste.ubuntu.com/p/nypvBh9Gfh/ int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) { int *a; int i ,j ,k; int n = 0; if(nums1Size &gt; nums2Size) k = nums2Size; else k = nums1Size; a = (int *)malloc(sizeof(int) * k ); for(i = 0 ;i &lt; nums2Size ;i++){ for(j = 0 ;j &lt; nums1Size ;j++) { if(nums2[i] == nums1[j]) { a[n] = nums2[i]; n++; nums1Size--; for(j ;j &lt;nums1Size ;j++) { nums1[j] = nums1[j+1]; } break; } } } *returnSize = n; return a; } 主要思路为先定义出存储交集的数组大小，然后用两重循环判断交集数，在这个过程中，要考虑到移除已经存储的交集，所以用向前推覆盖交集。 第三题代码：https://paste.ubuntu.com/p/PRbcmvpqxC/ int* plusOne(int* digits, int digitsSize, int* returnSize) { int *a; int i = 0, j = 0; a = (int *)malloc(sizeof(int) *digitsSize+1 ); for (i=digitsSize-1; i&gt;=0; i--) { if (i == digitsSize-1) a[i] = digits[i] + 1; else a[i] = digits[i]; if (a[i] == 10 &amp;&amp; i != 0) { a[i] = 0; digits[i-1] =digits[i-1]+1; } else if (a[i] == 10 &amp;&amp; i == 0) { digitsSize += 1; a[0] = 1; for (j=1; j&lt;digitsSize; j++) { a[j] = 0; } } } *returnSize = digitsSize; return a; } 主要思路为考虑到可能会有进位的情况，所以先定义出一个比原来数组大小大1的用于返回的数组，然后分最后一位是否为9，需不需要进位分类讨论即可。","link":"/2018/12/25/leetcode3/"},{"title":"leetcode2","text":"第一题代码：https://paste.ubuntu.com/p/VGHbTDm686/ int maxProfit(int* prices, int pricesSize) { int profit; int x,i = 0; profit=0; if(pricesSize==0) return 0; for(x=0;x&lt;pricesSize-1;x++) { if(prices[x+1]-prices[x]&gt;0) { profit=profit+(prices[x+1]-prices[x]); } } return profit; } 主要思路就是将前后差值为正之和算出来即可 第二题代码：https://paste.ubuntu.com/p/qJysqwZPwM/ void rotate(int* nums, int numsSize, int k) { int x,y; int cun; for(x=0;x&lt;k;x++) { cun=nums[numsSize-1]; for(y=numsSize-2;y&gt;=0;y--) { nums[y+1]=nums[y]; } nums[0]=cun; } } 主要思路为上次的原地算法，先保存最后一位数，再将数往后退，再将最后一位的值赋给第一位即可 第三题代码：https://paste.ubuntu.com/p/mSytVKspMG/ bool containsDuplicate(int* nums, int numsSize) { int x,y; for(x=0;x&lt;numsSize;x++) { for(y=x+1;y&lt;numsSize;y++) { if(nums[x]==nums[y]) { return true; break; } } } return false; } 主要思路为二重循环比较每一个数，直至得到相同或者循环结束。 在编写的时候遇到超时的情况，主要为最后一个案例量大，用二重循环耗时长，在改进部分代码后，勉强通过。","link":"/2018/12/12/leetcode2/"},{"title":"从排序数组中删除重复项","text":"参考的pre用于计算和计数，首先它遇到相同的数进行下次比较，然后直至遇到不同的数，开始使用原地算法覆盖之前相同的数字达到删除效果，同时进行计数。pre最后要加1。我的算法在遇到开头多次重复的数字时，会陷入死循环，在我添加判断用于对付这种情况时，开头的循环无法同时满足两种情况，怎么改都无法实现（很难受）。我的思路为比较前后两个数，如果相同则进行原地算法进行，运用定义的一个数记删除了几次，然后原长度-定义的数=输出，在遇到开头相同的数字出现了问题，无法平衡循环和计数的矛盾。 我的（有点长）： int removeDuplicates(int* nums, int numsSize){ int x=0,a,b,len=0,flag=0; for(x=0;x&lt;=numsSize-flag;x++) { if(nums[0]==nums[1]) { for(b=x;b&lt;=numsSize-1-flag;b++) { nums[b]=nums[b+1]; } flag=flag+1; } else { for(a=x+1;a&lt;=numsSize-flag;a++) { if(nums[a]==nums[x]) { for(b=x+1;b&lt;=numsSize-1;b++) { nums[b]=nums[b+1]; } flag=flag+1; x=0; } } } } len=numsSize-flag; return len;} 参考的 int removeDuplicates(int* nums, int numsSize) { int pre = 0, cur = 0; if (numsSize == 0) return 0; while (cur &lt; numsSize) { if (nums[pre] == nums[cur]) { cur++; } else { nums[++pre] = nums[cur++]; } } return pre + 1;}","link":"/2018/11/30/leetcode1/"}],"tags":[{"name":"c","slug":"c","link":"/tags/c/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"周报","slug":"周报","link":"/categories/周报/"},{"name":"学习","slug":"学习","link":"/categories/学习/"},{"name":"解题思路","slug":"解题思路","link":"/categories/解题思路/"}]}